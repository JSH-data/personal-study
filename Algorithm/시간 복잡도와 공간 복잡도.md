- **알고리즘 계산 복잡도는 시간 복잡도, 공간 복잡도 두 가지 척도로 표현될 수 있습니다.**
- **시간과 공간은 반비례적인 경향이 있기 때문에 알고리즘의 척도는 시간 복잡도를 위주로 판단합니다.**

# 시간복잡도

### 시간복잡도란?

- 알고리즘의 수행 시간을 분석할 때 시간 복잡도를 사용합니다.
- 수행 시간은 실행환경에 따라 다르게 측정되기 때문에 기본 연산의 실행 횟수로 수행 시간을 평가합니다.

### 기본 연산 종류

1. 데이터의 입출력 : copy, move..
2. 산술 연산 : add, multiply
3. 제어 연산 : if, while

### 시간 복잡도의 3가지 경우

1. 최선의 경우 : 빅 오표기법으로 표현하며 최선의 시나리오로 최소 이만한 시간이 걸림
2. 최악의 경우 : 빅 오 표기법 사용, 최악의 시나리오로 아무리 오래 걸려도 이 시간보다 덜 걸림
    - 알고리즘이 복잡해질수록 평균적인 경우는 구하기가 매우 어려워 지기 때문에 최악의 경우로 알고리즘의 성능을 파악합니다.
3. 평균적인 경우 : 빅 세타 표기법 사용, 평균 시간을 나타냄

### 시간 복잡도의 계산

- 시간 복잡도는 일반적으로 **빅오 표기법**으로 나타냅니다.
- 연산 횟수가 다항식으로 표현될 경우, 최고차항을 제외한 모든 항과 최고차항의 계수를 제외시켜 나타냅니다.
    - ex) n^2 + 2n = O(n^2)

## 시간 복잡도 표기

### O(1) - 상수 시간

- 입력 크기(n)에 상관없이 일정한 연산을 수행하면 시간복잡도는 O(1)입니다.

```jsx
function constant(n) {
	console.log(n)
}
```

### O(logN) - 로그 시간

- 입력 크기(N)가 커질 때 연산 횟수가 logN에 비례해서 증가하면 시간 복잡도는 O(logN)입니다.

```jsx
function log(n) {
	for(let i=0; i<n; i*2) {
		...	
	}
}
```

- 위 알고리즘은 i 값이 반복할 때마다 2배씩 증가합니다. 이것을 k번 반복하면 2^k = N
- 양쪽에 로그를 취하면 k = logN

### O(n) - 선형 시간

- 입력 크기(n)가 커질 때 연산 횟수가 n에 비례해서 증가하면 시간 복잡도는 O(n)입니다.

```jsx
function linear(n) {
	for(let i=0; i<n; i++) {
		...	
	}
}
```

### O(n^2) - 2차 시간

- 입력 크기(n)가 커질 때 연산 횟수가 n^2에 비례해서 증가하면 시간 복잡도는 입니다.

```jsx
for(let i=0; i < n; i++) {
  for(let j=0, j < n; j++) {
    ...
  }
}
```

### O(2^n) - 지수 시간

- 입력 크기가 커질 때 연산수가 2^n에 비례해서 증가하면 시간 복잡도는 입니다.

```jsx
function func(n) {
  if (n <= 1) 
    return n;
  return func(n-1) + fun(n-2);
}
```

### 성능 그래프

![[시간복잡도.png]]

- 왼쪽으로 갈수록 시간 복잡도가 큰 알고리즘입니다

# 공간복잡도

### 공간 복잡도란?

- 공간 복잡도는 알고리즘에서 사용하는 메모리 양을 나타냅니다.
- 프로그램을 실행 및 완료하는데 얼마나 많은 저장 공간이 필요한지!
- 총 필요한 저장공간 = S(P) = c + Sp(n)
    - c : 고정 공간(상수이기 때문에 공간 복잡도는 가변 공간에 의해 좌우됩니다)
    - Sp(n) 가변 공간

### 공간 복잡도 계산

- 공간 복잡도 계산은 알고리즘에서 실제 사용되는 저장 공간을 계산하면 됩니다

```jsx
function factorial(n)
{
    if(n > 1) return n * factorial(n - 1);
    else return 1;
}
```

- 위 예제는 n이 1 이하일 때까지 함수가 재귀적으로 호출되므로 스택에는 n부터 1까지 모두 쌓이게 될겁니다.
- 따라서 공간 복잡도는 O(n)

```jsx
function factorial(n)
{
    let i = 0;
    let fac = 1;
    for(i = 1; i <= n; i++)
    {
        fac = fac * i;
    }
    return fac;
}
```

- n에 값에 상관없이 스택에는 n과 i 그리고 fac 변수만 저장됩니다