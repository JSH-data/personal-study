---
tags:
  - Stack
sticker: emoji//1f534
Link: https://school.programmers.co.kr/learn/courses/30/lessons/154539
---
## 문제
정수로 이루어진 배열 `numbers`가 있습니다. 배열 의 각 원소들에 대해 자신보다 뒤에 있는 숫자 중에서 자신보다 크면서 가장 가까이 있는 수를 뒷 큰수라고 합니다.  
정수 배열 `numbers`가 매개변수로 주어질 때, 모든 원소에 대한 뒷 큰수들을 차례로 담은 배열을 return 하도록 solution 함수를 완성해주세요. 단, 뒷 큰수가 존재하지 않는 원소는 -1을 담습니다.


## 접근 방식, 활용한 알고리즘
- 배열을 순회하며 자신에게 해당되는 뒷 큰 수를 찾습니다. 

## 풀이
- 첫번째 풀이
```javascript
function solution(numbers) {
    const answer = [];
    const compare = []
    
    for(let i = 0; i < numbers.length - 1; i += 1) {
        const originalAnswerLen = answer.length;
        
        for(let j = i + 1; j < numbers.length; j += 1) {
            if(numbers[i] < numbers[j]) {
                answer.push(numbers[j])
                
                break;
            }
        }
        
        if(originalAnswerLen === answer.length) answer.push(-1);
    }
    
    answer.push(-1)
    
    return answer
}
```
- 두번째 풀이
```javascript
function solution(numbers) {
    const answer = Array.from({ length: numbers.length }, () => -1);
    const stack = [];
    
    for(let i = numbers.length - 1; i >= 0; i -= 1) {
        while (stack.length !== 0 && stack.at(-1) <= numbers[i]) {
            stack.pop();
        };
        
        if(stack.length) answer[i] = stack.at(-1);
        
        stack.push(numbers[i])
    }
    
    return answer
}
```
### 시간 복잡도
- O(N)

### 공간 복잡도
- O(N)

## 풀지 못한 이유
- O(N^2)의 시간복잡도로 풀었기 때문에 풀지 못함

## 참고한 풀이
```javascript
function solution(numbers) {

    const length = numbers.length;
    const answer = Array.from({length}, () => -1);
    const stack = [];

    for (let i = length - 1; i >= 0; i--) {
        while (stack.length !== 0 && numbers[i] >= stack.at(-1)) stack.pop();
        if (stack.length !== 0) answer[i] = stack.at(-1);
        stack.push(numbers[i]);
    }
    return answer;
}
```