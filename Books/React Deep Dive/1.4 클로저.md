### 1.4.1 클로저의 정의
- **클로저는 함수와 그 함수가 선언된 어휘적 환경(Lexical Scope)의 조합입니다.** 
```js
function add() {
	const a = 10; // 유효범위: add 함수 전체

	// "add" 함수 내부에서 선언된 "innerAdd" 함수는 선언된 위치 덕분에 변수 "a"에 접근할 수 있습니다.
	// 즉, 선언된 어휘적 환경은 코드가 작성된 환경(정적인 위치)을 의미합니다.
	function innerAdd() {
		const b = 20; // 유효범위: innerAdd 함수 전체
		
		console.log(a + b);
	};
	
	innerAdd(); // 30
};

add();
```

### 1.4.2 변수의 유효 범위, 스코프
- 클로저는 변수의 유효 범위에 따른 어위적 환경에 의해 결정됩니다. 이러한 변수의 유효 범위를 **스코프**라고 부릅니다.
#### 전역 스코프
- 변수를 전역 레벨에 선언하는 것을 **전역 스코프**라고 합니다.
- 전역 스코프에서 변수를 선언하는 경우 코드 어디에서나 변수에 접근이 가능합니다. 
- 브라우저에서는 **window**, Node.js는 **global** 객체가 전역 객체이며 이 객체들에게 전역 레벨의 스코프가 바인딩됩니다. 
#### 함수 스코프
- 자바스크립트는 기본적으로 함수 레벨 스코프를 따릅니다. 특정 상황에서 블록 스코프를 따르기도 합니다. 
```js
// 함수 스코프
function scope1() {  
  var x = 100;  
  
  console.log(x); // 100  
  
  function scope2() {  
    var x = 1000;  
  
    console.log(x); // 1000  
  }  
  
  scope2();  
}  
  
scope1();

// 블록 레벨 스코프
if (true) {
	const x = 200;
}

console.log(x) // Error!
```

### 1.4.3 클로저의 활용
- 클로저를 활용하는 경우 다음과 같은 이점을 확보할 수 있습니다. 
	- 변수에 직접 접근하여 수정하는 것을 방지할 수 있습니다.
	- 변수에 접근하는 경우 부가 작업을 진행할 수 있습니다. 
	- 변수에 접근하는 방식을 제한할 수 있습니다. 
```js
// 누구나 접근이 가능한 전역 변수
let counter = 0;

function handleClick() {
	counter ++;
}

// 외부에서 counter에 접근 불가능
function Counter() {  
  let counter = 0;  
  
  return {  
    increase: function () {  
      return ++counter;  
    },    decrease: function () {  
      return ++counter;  
    },    counter: function () {  
      return counter;  
    },  };  
}

console.log(c.increase());  
console.log(c.increase());  
console.log(c.decrease());  
console.log(c.counter());
```
#### 리액트에서의 클로저
- 리액트에서 클로저를 활용하는 대표적인 예시로는 **useState**가 있습니다. 
```js
function Component() {
	const [state, setState] = useState(0);

	function handleClick() {
		// useState의 호출은 상위 스코프에서 일어났지만 계속해서 내부 상태에 접근이 가능합니다. 
		setState((prev) => prev + 1); 
	}
}
```

### 1.4.4 주의할 점
- 전역 레벨 변수를 클로저로 사용하는 경우 예기치 못한 상황이 발생할 수 있기 때문에 스코프의 유효 범위를 좁혀주어야합니다.
```js
// 5를 5번 호출합니다. 
for(var i = 0; i < 5; i++) {
	setTimeout(() => {
		console.log(i);
	}, i * 1000)
}

// let을 통해 블록 스코프를 만들었습니다.
// 이제 0, 1, 2, 3, 4를 정상적으로 호출합니다. 
for(let i = 0; i < 5; i++) {
	setTimeout(() => {
		console.log(i);
	}, i * 1000)
}

// 즉시 실행 함수를 통해 스코프를 새롭게 생성합니다.
// 이제 0, 1, 2, 3, 4를 정상적으로 호출합니다. 
for (var i = 0; i < 5; i++) {  
	setTimeout(  
	    (function (sec) {  
		    return function () {  
		        console.log(sec);  
		    };    
	    })(i),  
    i * 1000  
	);  
}
```
- 클로저는 생성될 때마다 그 선언적 환경을 기억해야 하므로 추가로 비용이 발생합니다.
```js
const tButton = document.getElementById("5");  

function heavyJob1() {  
	// 버튼이 클릭되는 순간 실행이되므로 메모리에 longArr가 적제되지 않습니다.
	const longArr = Array.from({ length: 1000000 }, (_, i) => i + 1);  
	console.log(longArr.length);  
}  

tButton.addEventListener("click", heavyJob1);

// 위 코드를 클로저로 구현
function heavyJob2() {  
	// 클로저 함수를 사용하기 위해 heavyJob2가 실행되므로 longArr가 버튼이 눌리기전에 메모리에 적제됩니다. 
	const longArr = Array.from({ length: 1000000 }, (_, i) => i + 1);  
	
	return function () {  
		 console.log(longArr.length);  
	};  
}  
  
const innerFunc = heavyJob2();  
  
tButton.addEventListener("click", innerFunc);
```
- Snapshot 1은 첫번째 코드, Snapshot 2는 두번째 코드를 실행시킨 결과입니다. 
![[Screenshot 2024-03-17 at 9.02.42 PM.png|300]]