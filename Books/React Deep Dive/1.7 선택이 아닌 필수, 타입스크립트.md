---
sticker: emoji//1f976
---
### 1.7.1 타입스크립트란?
- 기존 자바스크립트 문법에 타입을 가미한 것이 타입스크립트입니다. 
- 타입스크립트는 동적 언어인 자바스크립트의 한계를 벗어나 **타입 체크를 정적으로 런타임이 아닌 빌드 타임에 수행할 수 있게 도와줍니다.** 
- 자바스크립트에서 불가능한 일은 타입스크립트에서도 마찬가지로 불가능합니다. 
### 1.7.2 리액트 코드를 효과적으로 작성하기 위한 타입스크립트 활용법
#### any 대신 unknown
- **any**를 사용한다는 것은 사실상 타입스크립트가 제공하는 정적 타이핑의 이점을 모두 버리는 것이나 다름 없습니다. 
```ts
function doSomething(callback: any) {
	callback();
}

doSomething(1) // Runtime Error!!
```
- 타입을 단정할 수 없는 경우 **unknown** 타입을 활용하는 것이 좋습니다. 
- unknown 타입은 모든 값을 할당할 수 있는 `Top Type`이며 `Type narrowing` 없이 사용하는 것은 불가능합니다.
```ts
function doSomething(callback: unknown) {
	if(typeof callback === "function") {
		callback();
		
		return 
	}

	return new Error()
}
```
- unknown과 반대 타입인 never는 어떠한 타입도 들어올 수 없음을 의미합니다. 
```ts
type what1 = string & number // string과  number를 다 만족시킬 수 없기에 never 타입이되었습니다. 
```
#### 타입 가드를 적극 활용하자
- 조건문과 함께 타입 가드를 사용하면 타입을 효과적으로 줄일 수 있어 조금 더 명확하게 변수나 함수를 사용할 수 있습니다. 
##### instanceof
- **instanceof는** 지정한 인스턴스가 특정 클래스의 인스턴스인지 확인할 수 있는 연산자입니다.
- 아래의 예시는 타입 가드를 통해 에러의 종류에 따라 원하는 처리 내용을 추가하는 것을 보여줍니다. 
```ts
async function fetchSomething() {
	try {
		const response = await fetch("...");
		return await reponse.json()
	} catch(error) { // error는 unknown입니다. 
		if(error instanceof UnAuthorizedError) {
			// Do Something...
		}

		if(error instanceof UnExpectedError) {
			// Do Something...
		}

		throw error
	}
}
```
##### typeof
- 특정 요소에 대해 자료형을 확인할 수 있습니다. 
```ts
if(typeof value === "string") {
	// Do about string type
}
```
##### in
- 어떤 객체에 키가 존재하는지 확인하는 용도로 사용됩니다 
```ts
interface Student {
	age: number;
	score: number;
}

interface Teacher {
	name: string;
}

function doSchool(person: Student | Teacher) {
	if('age' in person) {
		person.age // Student로 확인 완료!
	}
}
```
#### 제네릭
- 제네릭은 함수나 클래스 내부에서 단일 타입이 아닌 다양한 타입에 대응할 수 있도록 도와주는 도구입니다. 
- 리액트에서 사용하는 useState에 제네릭을 선언하면 state 사용과 기본값 선언을 더 명확하게 할 수 있습니다. 
```ts
function getFirstAndLast<T>(list: T[]): [T, T] {
	return [list[0], list[list.length - 1]];
}

const [first, last] = getFirstAndLast([1, 2, 3, 4, 5])
// first, last는 모두 number 타입으로 추론됩니다. 

// In React
const [state, setState] = useState<string>("");
```
#### 인덱스 시그니처
- 인덱스 시그니처란 객체의 키를 정의하는 방식을 의미합니다. 
- 인덱스 시그니처를 사용하면 키에 원하는 타입을 부여하는 것이 가능합니다. 
```ts
type Hello = {
	[key in "hello" | "hi" ]: string 
};
```
- 위와같이 정의한 타입에 `Object.keys()`를 사용하는 경우 타입을 추론할 수 없습니다. 따라서 다음과 같이 단언을 할 수 밖에 없습니다. 
```ts
// Object.keys는 string[]을 반환합니다. 
(Object.keys(hello) as Array<keyof Hello>).map((key) => {
	const val = hello[key];

	return value;
})
```
- **Object.keys**가 **string[]** 타입을 반환하는 이유는 자바스크립트의 특징과 이를 구현하기 위한 타입스크립트의 구조적 타이핑의 특징 때문입니다. 
- 자바스크립트는 다른 언어에 비해 객체가 열려 있는 구조로 만들어져 있으므로 덕 타이핑으로 객체를 비교해야하는 특징이 있습니다. 
	- **덕 타이핑**: 객체의 타입이 클래스 상속, 인터페이스 구현 등으로 결정되는 것이 아니고 어떤 객체가 필요한 변수와 메서드만 지니고 있다면 그냥 해당 타입에 속하도록 인정해주는 것을 의미합니다. 
- 타입스크립트도 자바스크립트에 맞춰 모든 키가 들어올 수 있는 가능성이 열려 있는 객체의 키에 포괄적으로 대응하기 위해 반환값으로 string[] 타입을 제공합니다. 
```ts
type Car = { name: string };
type Truck = Car & { power: number };

function horn(car: Car) { }

const truck: Truck = {
	name: '비싼차',
	power: 100
}

// Car가 아니지만 Ok~!
horn(truck)
```

### 1.7.3 타입스크립트 전환 가이드
#### tsconfig 먼저 작성하기
- 타입스크립트를 작성하기 위한 환경을 만들기 위해서는 최상위 디렉터리에 tsconfig.json을 생성해야합니다. 
#### JSDoc과 @ts-check을 활용해 점직으로 전환하기
- 파일 최상단에 **//@ts-check**을 선언하고 **JSDoc**을 활용해 변수나 함수에 타입을 제공하면 타입스크립트 컴파일러가 자바스크립트 파일의 타입을 확인합니다.
- JSDoc을 사용하는 것은 많은 작업량을 요구하기 때문에 바로 .ts로 파일 확장자를 변경하는 것이 더 빠를 수 있습니다.
```js
// @ts-check

/**
* @type {string}
*/
const str = true; // Error
```
#### 타입 기반 라이브러리 사용을 위해 @types 모듈 설치하기
- 자바스크립트 기반으로 작성된 라이브러리를 설치해서 사용하고 있다면 타입스크립트에서 라이브러리를 정상적으로 사용하기 위해서는 **@types**라고 불리는 **DefinitelyTyped**를 설치해야합니다. 
#### 파일 단위로 조금씩 전환하기
- 의존성이 없는 유틸, 상수부터 전환하는 것을 추천합니다. 
- 해당 파일들을 전환하다보면 메인 코드 또한 조금씩 수정이 필요합니다. 