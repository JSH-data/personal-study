### 4.1 타입 확장하기
- 타입 확장은 기존 타입을 사용해서 새로운 타입을 정의하는 것을 말합니다. 
- TS에서는 interface와 type 키워드를 통해 타입을 정의하고 extends, 교차 타입, 유니온 타입을 사용하여 타입을 확장할 수 있습니다. 

#### 1. 타입 확장의 장점
- 타입 확장의 장점은 코드 중복을 줄이는 것입니다. 
```typescript
interface ICartItem extends Base {...}
type TCartItem = {...} & Base
```

#### 2. 유니온 타입
- 2개 이상의 타입을 조합하여 사용하는 방법입니다. 집합의 관점에서 합집합을 의미합니다. 
- 유니온 타입으로 선언된 값은 유니온 타입에 포함된 모든 타입이 공통으로 갖고 있는 속성에만 접근할 수 있습니다. 
```typescript
type union = A | B
```

#### 3. 교차 타입
- 기존 타입을 합쳐 필요한 모든 기능을 가진 하나의 타입을 만드는 것으로 이해할 수 있습니다. 
- 집합의 교집합과 개념이 비슷합니다. 
```typescript
type union = A & B
```
- 교차 타입이 서로 호한되지 않는 경우
```typescript
type IdType = string | number;
type Numeric = number | boolean;

type universal = IdType & Numeric; // number로 평가됩니다. 
```

#### 4. extends와 교차 타입
- 유니온 타입과 교차 타입은 type에서만 사용이 가능합니다. 
- extends 키워드는 교차타입과 100% 상응하지 않습니다. 
``` typescript
interface DeliveryTip {
	tip: number;
}

interface Filter extends DeliveryTip {
	tip: string; // Error! tip is number!
}

type DeliveryTip = {
	tip: number;
}

interface Filter = DeliveryTip & {
	tip: string; // 같은 속성에 대해 서로 호환되지 않는 타입은 never 타입!
}
```

### 4.2 타입 좁히기 - 타입 가드
- TS에서 타입 좁히기는 변수 또는 표현식의 타입 범위를 더 작은 범워로 좁혀나가나는 과정을 의미합니다. 
- 더 정확하고 명시적인 타입 추론을 할 수 있게 되고 복잡한 타입을 작은 범위로 축소하여 타입 안정성을 높일 수 있습니다. 

#### 1. 타입 가드에 따라 분기 처리하기
- 타입스크립트에서의 분기 처리는 조건문과 타입 가드를 활용하여 변수나 표현식의 타입 범위를 좁혀 다양한 상황에 따라 다른 동작을 수행하는 것을 말합니다. 
- 타입 가드는 런타임에 조건문을 활영하여 타입을 검사하고 타입 범위를 좁혀주는 기능을 말합니다.
- 타입 가드는 자바스크립트 연산자를 사용한 타입 가드와 사용자 정의 타입 가드로 구분할 수 있다. 
- 자바스크립트 연산자를 활용한 타입 가드는 `typeof`, `instanceof`, `in` 과같은 연산자를 사용해서 제어문으로 특정 타입 값을 가질 수 밖에 없는 상황을 유도하여 타입을 좁히는 방식입니다. 
- 사용자 정의 타입 가드는 사용자가 직접 어떤 타입으로 값을 좁힐지 지정하는 방식입니다. 

#### 2. 원시 타입을 추론할 때 typeof 연산자 활용하기
- 자바스크립트 타입 시스템에만 대응할 수 있는 `typeof`는 자바스크립트의 타입 시스템만 대응할 수 있습니다.
- 자바스크립트의 동작 방식으로 인해 null과 배열 타입등을 검증하는데 한계가 있습니다. 따라서 원시타입을 좁히는 용도로만 사용할 것을 권장합니다.
```typescript
if (typeof date === "string") {
	// date를 string으로 추론
}
```

#### 3. 인스턴스화된 객체 타입을 판별할 때 instanceof 연산자 활용하기
- `instanceof` 연산자는 인스턴스화된 객체 타입을 판별하는 타입가드로 사용이 가능합니다. 
- `A instanceof B` A의 프로토타입 체인에 생성자 B가 존재하는지를 검사 후 결과로 Boolean을 반환합니다. 

#### 4. 객체의 속성이 있는지 없는지에 따른 구분: in 연산자 활용하기
- `in` 연산자는 객체에 속성이 있는지 확인한 결과를 Boolean으로 반환합니다. 
- 프로토타입 체인으로 접근할 수 있는 속성이면 전부 true를 반환합니다. (  )
- B 객체 내부에 A 속성이 있는지 확인 하는 것이므로 undefined를 할당하는 것은 의미가 없습니다. 

#### 5. is 연산자로 사용자 정의 타입 가드 만들어 활용하기
- 반환 타입이 타입 명제인 함수를 정의하여 타입 가드 함수를 만들 수 있습니다. 
- 타입 명제는 `A is B` 형식으로 작성되는데 A는 매개변수 이름이고 B는 타입입니다. 
- 참거짓의 진릿값을 반환하면서 반환 타입을 타입 명제로 지정하게 되면 반환 값이 참일 때 A 매개변수의 타입을 B타입으로 취급하게 됩니다. 
```typescript
const destinations : Destination[] = [...];

const isDestination 
	= (x: string): x is Destination => destinations.includes(x);

const destinationNames: Destination[] = []

if (isDestination(str)) {
	destinationNames.push(DestinationNameSet[str])
	// is를 사용하지 않는다면 str을 any로 간주하여 Error가 발생합니다. 
}
```

### 4.3 타입 좁히기 - 식별할 수 있는 유니온
- 태그된 유니온으로도 불리는 식별할 수 있는 유니온은 타입 좁히기에 널리 사용되는 방식입니다. 

#### 2. 식별할 수 있는 유니온
- 식별할 수 있는 유니온이란 타입간의 구조 호환을 막기위해 타입마다 구분할 수 있는 판별자를 달아 주어 포함 관계를 제거하는 것이다.
```typescript
type TextError = {
	errorType: "Text";
	errorCode: string;
	errorMessage: string;
};

type ToastError = {
	errorType: "TOAST";
	errorCode: string;
	errorMessage: string;
	toastShowDuration: number;
};

type UnionError = TextError | ToastError;
const errorArr: UnionError[] = [
	{
		errorType: "Text",
		errorCode: "100",
		errorMessage: "xprtmdror",
	},
	{
		errorType: "Text",
		errorCode: "100",
		errorMessage: "xprtmdror",
		toastShowDuration: 1000, // Error 발생 공존 불가능
	},
]
```
#### 3. 식별할 수 있는 유니온의 판별자 선정
- 식별할 수 있는 유니온의 판별자는 다른 타입으로 쪼개지지 않고 오직 하나의 정확한 값을 가지는 유닛 타입으로 선언되어야 정상적으로 동작합니다.
	- 리터럴 타입, null, undefined, true, 등...
- 다양한 타입을 할당할 수 있는 void, string, number는 제외됩니다. 

### 4.4 Exhaustiveness Checking으로 정확한 타입 분기 유지하기
- 철저함을 나타내는 Exhaustiveness는 모든 케이스에 대해 철저하게 타입을 검사하는 것을 말하며 타입 좁히기에 사용되는 패러다임 중 하나입니다. 
- 모든 케이스에 대해 분기 처리를 해야만 유지보수 측면에서 안전하다고 생각되는 경우 Exhaustiveness Checking을 통해 모든 케이스에 대한 타입 검사를 개발자에게 강제할 수 있습니다.
```typescript
type ProductPrice = "10000" | "20000" | "5000";

const getProductName = (productPrice: ProductPrice): string => {
	if (productPrice === "10000") return "배민상품권 1만원";
	if (productPrice === "20000") return "배민상품권 1만원";
	// if (productPrice === "5000") return "배민상품권 1만원";	
	else {
		exhaustiveCheck(productPrice)
		// 에러 발생!
		return "배민상품권"
	}
}

const exhaustiveCheck = (param: never) => {
	throw new Error("type error");
}
```