### 3.1 타입스크립트만의 독자적 타입 시스템
- 타입스크립트의 타입 시스템이 내포하고 있는 개념은 모두 자바스크립트에서 기인하였습니다. 
- 예시로 any 타입은 자바스크립트에 사용방식과 일치하는 타입스크립트의 독자적인 타입입니다.
- 다음 사진은 타입스크립트의 타입 계층 구조를 나타냅니다. 
![[Screenshot 2024-02-20 at 10.42.32 PM.png]]
#### 1. any 타입
- 자바스크립트에 존재하는 모든 값을 오류 없이 받을 수 있는 타입입니다.
- `tsconfig`에서 `noImplicitiAny` 옵션을 활성화하면 타입이 명시되지 않은 any 타입에 대한 경고를 발생시킬 수 있습니다. 
- 어쩔 수 없이 any 타입을 사용하는 3가지 사례
	- **개발 단계에서 임시로 값을 지정해야 할 때**
	- **어떤 값을 받아올지 또는 넘겨줄지 정할 수 없을 때**
	- **값을 예측할 수 없을 때 암묵적으로 사용**

#### 2. unknown 타입
- any 타입과 유사하게 모든 타입의 값이 할당될 수 있습니다. 그러나 any를 제외한 다른 타입으로 선언된 변수에는 unknown 타입 값을 할당할 수 없습니다. 
![[Screenshot 2024-02-27 at 9.14.48 PM.png]]
```typescript
let unknownVal: unknown

let someVal: number = unknownVal // 불가

const unFunc: unknown = () => console.log('Error');

unFunc() // Error 발생! 
```
- 타입스크립트만의 타입시스템으로 무엇이 할당될지 아직 모르는 상태의 타입을 의미합니다. 
- unknown 타입은 어떤 타입이 할당되었는지 알 수 없음을 나타내기 때문에 unknown 타입으로 선언된 변수는 값을 가져오거나 내부 속성에 접근할 수 없습니다. 
- any 타입과 유사하지만 타입 검사를 강제하고 타입이 식별된 후에 사용할 수 있기 때문에 any 타입보다 더 안전합니다. 
#### 3. void 타입
- 자바스크립트에서 함수에 명시적인 반환문을 작성하지 않는다면 undefined가 반환됩니다. 
- 타입스크립트에서는 함수가 어떤 값을 반환하지 않는 경우 void를 사용합니다.
- void 타입에는 undefined 혹은 null이 할당될 수 있습니다. 

#### 4. never 타입
- never 타입은 값을 반환할 수 없는 타입을 의미합니다. 
- 값을 반환할 수 없는 2가지 예시
	- **에러를 던지는 경우**
	- **무한히 함수가 실행되는 경우**
- never 타입은 모든 타입의 하위 타입이며 자신을 제외한 어떤 타입도 never 타입에 할당될 수 없습니다. 

#### 5. Array 타입
- 배열 타입으로 가리키는 Array 키워드는 자바스크립트의 `Obejct.prototype.toString.call()` 연산을 통해 확인할 수 있습니다. 
- 배열은 **[]** 키워드를 통해 타입을 명시할 수 있습니다. 이때 배열보다 좁은 범위인 튜플을 가리키게 됩니다. 
- 배열 타입을 지정하는 방법
```typescript
const arr1: number[] = []

// 제네릭을 활용한 문법, 유니온 타입을 활용해 여러가지 타입이 배열에 존재할 수 있습니다. 
const arr2: Array<number | string> = []

// 배열과 튜플을 활용한 타입
const res: [number, string, ...string[]] = [400, "ss", "sss", "sssss"]

// 옵셔널 튜플
const tu: [number, number, number?] = [1, 2]
```
- 앞서 말한 튜플 타입은 배열 타입의 하위 타입으로 배열 기능에 길이 제한까지 추가한 타입 시스템이라고 볼 수 있습니다. 

#### 6. enum 타입
- 열거형이라고도 부르며 타입스크립트에서 지원하는 특수한 타입입니다. 
- 자바스크립트의 객체와 비슷하며 명명한 각 멤버의 값을 스스로 추론합니다. 기본적인 추론 방식은 0부터 1씩 늘려가며 값을 할당하는 것입니다. 
```typescript
enum aLang {
 ts, // 0
 js, // 1
}

enum bLang {
 java: "java", 
 c: "c",
 python = 300,
 kotlin, // 301 
 go, // 302
}
```
- 열거형은 관련이 높은 멤버를 모아 문자열 상수처럼 사용하고자 할 때 유용하게 쓸 수 있습니다. 
- 단 숫자로 이뤄지거나 자동추론한 enum은 주의가 필요합니다. 조금 더 안전하게 쓰길 원한다면 const enum을 활용하는 것이 좋으며 가장 안전한 방법은 문자열 열거형을 사용하는 것입니다. 
- 열거형은 번들링과정에서 트리 쉐이킹이 되지 않는다는 단점이 존재합니다. 

### 3.2 타입 조합
#### 1. 교차 타입(intersection)
- 기존 타입을 합쳐 해당 타입의 모든 멤버를 가지는 새로운 타입을 생성하는 것 입니다. 
- `&`을 사용해 표기하며 결과물에 alias를 붙일 수 있습니다. 

#### 2. 유니온 타입(Union)
- OR을 나타내는 타입으로 `| `로 표기합니다. 
- 특정 변수가 가질 수 있는 타입을 전부 나열하는 용도로 사용됩니다. 

#### 3. 인덱스 시그니처
- 특정 타입의 속성 이름을 알 수 없지만 속성값의 타입을 알고 있을 때 사용하는 문법입니다. 
- 인덱스 시그니처 선언 시 추가로 명시되는 속성은 인덱스 시그니처에 포함되어야합니다. 
```typescript
interface IndexSignature {
	[key: string]: number | boolean;
	name: string // Error
}
```

#### 4. 인덱스드 엑세스 타입
- 다른 타입의 특정 속성이 가지는 타입을 조회하기 위해 사용됩니다.
- 인덱스에 사용되는 타입 또한 그 자체로 타입이기 때문에 유니온 타입, keyof 타입 별칭 등의 표현을 사용할 수 있습니다.
```typescript
type Ex = {
	a: number;
}

type id = Ex['a']
type id = Ex[keyof Ex]
```
- 배열의 타입은 숫자로 가져올 수 있습니다. 
```typescript 
type ElementOf<T> = typeOf T[number];
```
#### 5. 맵드 타입
- 다른 타입을 기반으로 한 타입을 선언할 때 사용하는 타입입니다. 
- 인덱스 시그니처와 함께 반복적인 타입 선언을 효과적으로 줄일 수 있습니다. 
- readonly 혹은 옵셔널 파라미터도 추가 혹은 제거할 수 있습니다. 
- as 키워드를 통해 키를 재지정할 수 있습니다. 
```typescript
type BottonSheet {
	[index in BOTTOM_SHEET_ID as `{index}`]: string
}
```

#### 6. 템플릿 리터럴 타입
- 자바스크립트에 템플릿 리터럴 문자열을 사용하여 문자열 리터럴 타입을 선언하는 문법입니다. 
```typescript
type Stage = "init" | "image"

type Stage = `${Stage}-stage` // "init-stage" | "image-stage"
```
#### 7. 제네릭
- 정적 언어에서 다양한 타입 간에 재사용성을 높이기 위해 사용하는 문법입니다. 
- 함수, 타입, 클래스 등에서 내부적으로 사용할 타입을 미리 정해두지 않고 타입 변수를 사용해서 해당 위치를 비워 둔 다음에 그 값을 사용할 때 외부에서 타입 변수 자리에 타입을 지정하여 사용하는 방식입니다. 
- 타입 변수는 T 같이 꺾쇠괄호 내부에 정의합니다. 타입 변수명으로 T, E, K 등 한 글자로 된 이름을 많이 사용합니다.
- 제네릭을 호출할 때 꺾쇠괄호 안에 타입을 명시해야하는 것은 아닙니다. 생략하는 경우 컴파일러가 인수를 보고 타입을 추론해줍니다. 
- 특정 요소 타입을 알수 없는 경우 제네릭 타입에 기본값을 추가할 수 있습니다. 
- extends를 통해 제네릭 타입에 제약을 걸 수 있습니다 
```typescript
interface Event<T = HTMLElement> ... // 기본값

interface Event<T extends HTMLElement> ... // 제약
```

### 3.3 제네릭 사용법
#### 1. 함수의 제네릭
- 어떤 함수의 매개변수, 반환 값에 다양한 타입을 넣고 싶을 때 제네릭을 사용할 수 있다. 

#### 2. 호출 시그니처의 제네릭
- 호출 시그니처를 사용할 때 제네릭 타입을 어디에 위치시키는지에 따라 타입의 범위와 제네릭 타입을 언제 구체 타입으로 한정할지를 결정할 수 있습니다. 
```typescript
export type UseRequesterHookType = 
	<RequestData1 = void, RequestData2 = void>
	(baseURL?: string | Headers, defaultHeader?: Headers) 
	=> [RequestStatus, ...]
```
- 괄호 앞에서 `<RequestData = void, RequestData = void>`을 선언했기 때문에 제네릭 타입을 구체 타입으로 한정합니다. 

#### 3. 제네릭 클래스
- 외부에서 입력된 타입을 클래스 내부에 적용할 수 있는 클래스입니다. 
- 특정 메서드만을 대상으로 제네릭을 지정하는 것도 가능합니다. 
```typescript
class Local<T> {
	// ...
}
```

#### 4. 제한된 제네릭
- 매개변수에 대한 제약 조건을 설정하는 기능을 말합니다. 
- 타입 매개변수가 특정 타입으로 묶인경우 키를 **바운드 타입 매개변**수라고 부릅니다. 그리고 제한한 타입을 **키의 상한 한계**라고 합니다.
```typescript
type Error<Key extends string> ...
```
- 상속할 수 있는 타입으로는 인터페이스, 클래스도 올 수 있으며 유니온 타입도 가능합니다. 

#### 5. 확장된 제네릭
- 제네릭 타입은 여러 타입을 상속받을 수 있으며 타입 매개변수를 여러개 둘 수 있습니다. 
```typescript
class APIRes<Ok, Err = string, else extends Ok> {
 // ...
}
```
