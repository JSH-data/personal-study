### 5.1 조건부 타입
- 타입스크립트에서는 조건부 타입을 사용해 조건에 따라 출력 타입을 다르게 도출할 수 있습니다. 
- 삼항 연산자와 동일하게 Condition ? A : B 형태를 가집니다.

#### 1. extends와 제네릭을 활용한 조건부 타입
```typescript
interface Bank { ... };
interface Card { ... };

type CardMethod<T> = T extends "card" ? Card : Bank;

type CardPayMethodType = CardMethod<"card">;
type BankPayMethodType = CardMethod<"bank>;
```

#### 2. 조건부 타입을 사용하지 않았을 때의 문제점
- 인자에 따라 반환되는 타입을 다르게 설정하는데 어려움이 있습니다. 
```typescript
type PayMethodType = PayMethodInfo<Card> | PayMethodInfo<Bank>; 

export const useGetRegisteredList 
	= (type: "card" | "appcard" | "bank"): UseQueryResult<PayMethodType[]> => {
	const url = `baemin/${type === "appcard" ? "card" : type}`;

	const fetcher = fetcherFactory<PaymMethodType[]>({
		onSuccess: (res) => {
			const usablePocketList = 
				res?.filter(
					(pocket: PocketInfo<Card> | PocketInfo<Bank>) => 
						pocket?.useType === "USE"
				) ?? [];
			return usablePocketList;
		}
	})
	
	const result = useCommonQuery<PayMethodType[]>(url, undefined, fetcher);

	return result;
}

// pocketList의 return type은 PocketInfo<Card>[] | PocketInfo<Bank>[] | undefined
const { data: pocketList } = useGetRegisteredList("card")
```

#### 3. extends 조건부 타입을 활용하여 개선하기 
- `PayMethodType`을 아래와 같이 개선할 수 있습니다. 
```typescript
type PayMethodType<T extends "card" | "appcard" | "bank"> = T extends | "card" | "appcard" ? Card : Bank;
```
- 위에서 작성한 API 함수를 다시 재정의해보겠습니다.
```typescript
export const useGetRegisteredList = <T extends "card" | "appcard" | "bank">(
	type: T
): UseQueryResult<PayMethodType<T>[]> => {
	const url = `baemin/${type === "appcard" ? "card" : type}`;

	const fetcher = fetcherFactory<PaymMethodType<T>[]>({
		onSuccess: (res) => {
			const usablePocketList = 
				res?.filter(
					(pocket: PocketInfo<Card> | PocketInfo<Bank>) => 
						pocket?.useType === "USE"
				) ?? [];
			return usablePocketList;
		}
	})
	
	const result = useCommonQuery<PayMethodType<T>[]>(url, undefined, fetcher);

	return result;
}

// pocketList의 return type은 PocketInfo<Card>[]
const { data: pocketList } = useGetRegisteredList("card")
```
- 제네릭과 extends를 함께 사용하여 타입을 제한하는 경우 잘못된 값을 넘길 수 없기 때문에 휴먼 에러를 방지할 수 있습니다. 
- extends를 활용해 조건부 타입을 설정하는 경우 조건부 타입을 사용해서 반환 값을 사용자가 원하는 값으로 구체화할 수 있습니다. 이에 따라 불필요한 타입 가드, 타입 단언 등을 방지할 수 있습니다.

#### 4. infer를 활용해서 타입 추론하기
- extends를 사용하는 경우 타입을 추론하는 infer 키워드를 사용할 수 있습니다. 
- 삼항 연산자를 사용한 조건문의 형태를 가지는데, extends로 조건을 서술하고 infer로 타입을 추론하는 방식을 취합니다. 
```typescript
// 제네릭으로 전달받은 T가 Promise로 래핑된 경우라면 K를 반환하고 그렇지 않은 경우 any를 반환하는 타입입니다. 
type UnpackPromise<T> = T extends Promise<infer K>[] ? K : any;

const promises = [Promise.resolve("Mark"), Promise.resolve(1)];
type what = UnpackPromise<typeof promises>; // string | number;
```
- 아래는 배달의 민족이 라이더 어드민에서 사용중인 Route 관련 타입입니다. 
```typescript
interface RouteBase {
	name: string;
	path: string;
	component: ComponentType;
}

export interface RouteItem {
	name: string;
	path: string;
	component?: ComponentType;
	pages?: RouteBase[];
}

export const routes: RouteItem[] = [
	{
		name: "기기 내역 관리",
		path: "./device-history",
		component: DeviceHistoryPage,
	},
	{
		name: "헬멧 인증 관리",
		path: "./helmet-certification",
		component: HelmetCertificationPage,
	},
]

export interface SubMenu {
	name: string;
	path: string;
}

export interface MainMenu {
	name: string;
	path?: string;
	subMenus?: SubMenu[];
}

export type MenuItem = MainMenu | SubMenu;
export const menuList: MenuItem[] = [
	{
		name: "계정관리",
		subMenus: [
			{
				name: "기기 내역 관리",
				path: "./device-history",
			},
			{
				name: "헬멧 인증 관리",
				path: "./helmet-certification",
			},
			{
				name: "운행 관리",
				path: "./operation",
			},
		]
	}
]
```
- 권한을 위한 name만을 추출하기 위헤 infer를 사용하면 다음과 같이 구성이 가능합니다.
```typescript
export interface MainMenu {
	// ...
	subMenus?: ReadonlyArray<SubMenu>;
}

export const menuList = [
	// ...
] as const;

interface RouteBase {
	name: PermissionNames;
	path: string;
	component: ComponentType;
}

export type RouteItem = 
	|
		{
			name: string;
			path: string;
			component?: ComponentType;
			pages: RouteBase[];
		}
	|   {
			name: PermissionNames;
			path: string;
			component: ComponentType;
		}

type UnpackMenuNames<T extends ReadonlyArray<MenuItem>> = T extends ReadonlyArray<infer U>
	? U extends MainMenu
		? U["subMenu"] extends infer V
			? V extends ReadonlyArray<SubMenu>
				? UnpackMenuNames<V>
				: U["name"]
			: never
		: U extends SubMenu
		? U["name"]
		: never
	:never;  

export type PermissionNames = UnpackMenuNames<typeof menuList> // ["기기 내역 관리, 헬멧 인증 관리, 운행 관리"]
```
- 해석 순서
	- U가 MainMenu 타입이라면 subMenus를 infer V로 추출합니다.
	- subMenus는 옵셔널한 타입이기 때문에 추출한 V가 존재한다면 UnpackMenuNames에 다시 전달합니다. 
	- V가 존재하지 않는다면 MainMenu의 name은 권한에 해당하므로 U\["name"\] 이다.
	- U가 MainMenu가 아니라 SubMenu에 할당할 수 있다면(U는 SubMenu 타입이기 때문에) U\["name"\]은 권한에 해당한다.

### 5.2 템플릿 리터럴 타입 활용하기 
- 타입스크립트에서는 유니온 타입을 사용하여 변수 타입을 특정 문자열로 지정할 수 있습니다. 
```typescript
type HeaderTag = "h1" | "h2"
```
- 타입스크립트 4.1부터 템플릿 리터럴 타입을 지원하여 위 타입을 아래와 같이 수정할 수 있습니다. 
```typescript
type HeaderNumber = "1" | "2"
type HeaderTag = `h${HeaderNumber}`

// 응용 방법
type Direction = 
| "top"
| "topLeft"
| "topRight"
| "bottom"
| "bottomLeft"
| "bottomRight"

type Vertical = "top" | "bottom"
type Horizon = "left" | "right"

type Upgrade = Vertical | `${Vertical}${Capitalize<Horizon>}`
```
- 단 너무 많은 유니온 타입은 추론하는데 오래걸리기 때문에 지양하는 것이 좋습니다. 

### 커스텀 유틸리티 타입 활용하기

#### 1. 유틸리티 함수를 활용해 중복 타입 선언 피하기
- 중복으로 타입을 선언하지 않고 Pick, Omit과 같은 유틸리티 함수를 활용하여 유지보수를 향상 시킬 수 있습니다. 

#### 2. PickOne 유틸리티 함수
- 타입스크립트에서 서로 다른 2개 이상의 객체를 유니온 타입으로 받을 때 타입 검사가 제대로 진행되지 않는 경우가 있습니다. 
- 이런 문제를 해결하기 위해 식별할 수 있는 유니온 기법을 자주 활용합니다. 

##### 식별할 수 있는 유니온으로 객체 타입을 유니온으로 받기
- 각 타입에 type이라는 공통된 속성을 추가하여 구분 짓는 방식입니다. 
```typescript
type Card = {

	card: string;
};

type Account = {

	account: string;
};

function withDraw(type: Card | Account) { 
	// 추론가능!
};
```
- 위 타입 추론 방식은 모든 타입에 type을 넣어줘야하는 불편함이 존재합니다. 위 타입 추론을 커스텀 타입을 통해 추론해보겠습니다. 
```typescript
type PickOne<T> = {
	[P in keyof T]:
		Record<P, T[P]> & Partial<Record<Exclude<keyof T, P>, undefined>>
}[keyof T]

function withDraw(type: PickOne<Card & Account>) { 
	// 추론가능!
};
```

#### NonNullable 타입 검사 함수를 사용하여 간편하게 타입 가드하기
- null 가드는 일반적으로 if문을 사용해서 가드할 수 있지만 `is` 키워드와 NonNullable 타입으로 타입 검사를 위한 유틸 할수를 만들어서 사용할 수도 있습니다. 
##### NonNullable 타입이란
- 타입스크립트에서 제공하는 유틸리티 타입으로 제네릭으로 받는 T가 null 또는 undefined일 때 never 또는 T를 반환하는 타입입니다. 
```typescript
type NonNullable<T> = T extends null | undefined ? never ? T;
```
##### null, undefined를 검사해주는 NonNullable 함수
- NonNullable 유틸리티 타입을 사용하여 null 또는 undefined를 검사해주는 타입 가드 함수를 만들어 쓸 수 있습니다. 
```typescript
function NonNullable<T>(value: T): value is NonNullable<T> {
	return value !== null && vallue !== undefined
}
```

##### Promise.all을 사용할 때 NonNullable 적용하기
- 아래는 광고 API 예시로 여러 광고를 조회합니다. 여러 광고중에서 하나의 API에서 에러가 발생한다고 해서 전체 광고가 보이지 않으면 안되므로 try-catch문을 활용하여 에러 발생 시 null을 반환합니다. 
```ts
class AdApi {
	static async operating(shopNo: number): Promise<AdCampign[]> {
		try {
			return await fetch('...');		
		} catch(error) {
			return null
		}
	}
}

const shoppingList = [
	{ shopNo: 100, category: "chicken" },
	{ shopNo: 101, category: "pizza" },
	{ shopNo: 102, category: "noodle" },
]

const shopAdCampaignList = 
	  await Promise.all(shopList.map((shop) => AdCampaignApi.operation(shop.shopNo)));

const shopAds = shopAdCampaignList.filter(NonNullable) // Array<AdCampign[]>으로 추론가능!
```

### 5.4 불변 객체 타입으로 활용하기
- 상숫값을 관리할 때 객체를 사용하는 경우 불변 객체로 선언하여 컴파일 단계에서 발생할 수 있는 실수를 방지할 수 있습니다. 

#### 1. Atom 컴포넌트에서 theme style 객체 활용하기
```ts
const colors = {
	black: "#00000",
	gray: "#22222",
	white: "#33333",
	mint: "#FFFFF",
} as const;

const theme = {
	colors: {
		default: colors.gray,
		...colors,
	},
	backgroundColor: {
		default: colors.white,
		gray: colors.gray,
		mint: colors.mint,
		black: colors.black,
	},
	fontSize: {
		default: "16px",
		small: "14px",
		large: "18px",
	}
}

type ColorType = keyof  theme.colors
type BackgroundType = keyof typeof theme.backgroundColor
type FontSizeType = keyof typeof theme.fontSize

interface Props {
	color?: ColorType;
	backgroundColor?: BackgroundType;
	fontSize?: FontSizeType;
	// ...
}

// 지정된 key를 제외한 값은 사용이 불가능합니다. 
const Button: ({ fontSize, backgroundColor, color, children }) => {
	return (
		<ButtonWrap>
			fontSize={fontSize}
			backgroundColor={fontSize}
			color={color}
		</ButtonWrap>
	)
}

const ButtonWrap = styled.button<Omit<Props, "...">>`
	color: ${({color}) => theme.color[color ?? "default"]}
	...
`
```

### 5.5 Record 원시 타입 키 개선하기
- 객체 선언 시 키가 어떤 값인지 명확하지 않다면 Record의 키를 string 혹은 number로 명시합니다. 
- 이러한 행위는 키가 유효하지 않더라도 컴파일 에러를 만들지는 않지만 런타임 에러를 만들어낼 수 있습니다. 

#### 1. 무한한 키를 집합으로 가지는 Record 
- 아래 객체는 무한한 키 집합을 가질 수 있게됩니다. 
```ts
type Category = string;

interface Food {
	name: string;
	// ...
}

const foodByCategory: Record<Category, Food[]> = {
	한식: [{name: "제육덮밥"}, {name: "불고기"}],
	// ...
}

foodByCategory["양식"];

foodByCategory["양식"].map((food) => console.log(food.name)); // 런타임에서 에러!

foodByCategory["양식"]?.map((food) => console.log(food.name)); // 옵셔널 체이닝 덕분에 에러가 나지 않습니다. 
```
#### 2. 유닛 타입으로 변경하기
```ts
type Category = "한식" | "일식" // 쪼개지지 않는 정확한 타입
```
#### 3. Partial을 활용하여 정확한 타입 표현하기
- 키가 무한한 상황에서 Partial을 통해 undefined일 수 있다고 표현할 수 있습니다. 
```ts
type PartialRecord<K extends string, T> = Partial<Record<K, T>>;

const foodByCategory: PartialRecord<Category, Food[]> = {
	한식: [{name: "제육덮밥"}, {name: "불고기"}],
	// ...
}

foodByCategory["양식"]; // undefined로 추론하기 때문에 개발자는 반드시 옵셔널 처리를 해야합니다. 
```


