### 8.1 리액트 컴포넌트의 타입
#### 1. 클래스 컴포넌트 타입
- 클래스 컴포넌트가 상속받는 React.Component와 React.PureComponent의 타입 정의는 위와 같으며 P와 S는 각각 props와 상태를 의미합니다. 
- 상태가 있는 컴포넌트일 때는 제네릭의 두 번째 인자로 타입을 넘겨주면 상태에 대한 타입을 지정할 수 있습니다. 
```ts
interface Component<P = {}, S = {}, SS = any> extends ComponentLifecycle<P, S, SS> {}

class Component<P, S> { }

class PureComponent<P = {}, S = {}, SS = any> extends Component<P, S, SS> {}
```
#### 2. 함수 컴포넌트 타입
- `React.FC`와 `React.VFC`는 리액트에서 함수 표현식을 사용한 함수 컴포넌트의 타입 지정을 위해 제공되는 타입입니다. 
- 두 타입의 차이는 `children` 타입의 허용 여부입니다. 
- 리액트 18에서부터는 `React.VFC`는 제거되었고 React.FC에서 children타입이 사라졌습니다.
```ts
const Welcome: React.FC<Props> = ({name}) => {};
```
#### 3. Children props 타입 지정
- 가장 보편적인 children 타입은 `ReactNode | undefined`가 됩니다. 
- `ReactNode`는 `ReactElement`외에도 `boolean`, `number` 등 여러 타입을 포함하고 있는 타입으로 더 구체적으로 타이핑하는 용도에는 적합하지 않습니다. 
#### 4. render 메서드와 함수 컴포넌트의 반환 타입 - React.ReactElement vs JSX.Element vs React.ReactNode
- `React.createElement`를 호출하는 형태의 구문으로 변환하면 `React.createElement`의 반환 타입은 `ReactElement`입니다. 
- 리액트는 가상 DOM을 기반으로 렌더링하는데 가상 DOM의 엘리먼트는 `ReactElement` 형태로 저장됩니다. 즉, `ReactElement` 타입은 리액트 컴포넌트를 객체 형태로 저장하기 위한 포멧입니다. 
```ts
interface ReactElement<P = any, T extends string | JSXElementConstructor<any> = string | JSXElementConstructor<any>> {
	type: T;
	props: P;
	key: Key | null;
}
```
- JSX.Element 타입은 리액트의 ReactElement를 확장하고 있는 타입이며 글로벌 네임스페이스에 정의되어 있어 외부 라이브러리에서 컴포넌트 타입을 재정의할 수 있는 유연성을 제공합니다. 
```ts
declare global {
	namespace JSX {
		interface Element extends React.ReactElement<any, any> {}
	}
}
```
- React.Node 타입은 ReactElement 외에도 boolean, string, number 등의 여러 타입을 포함하고 있다.![[Screenshot 2024-03-30 at 4.57.04 PM.png]]
#### 5. ReactElement, ReactNode, JSX.Element 활용하기
- ReactElement, ReactNode, JSX.Element는 모두 리액트의 요소를 나타내는 타입입니다. 
##### ReactElement
- JSX는 자바스크립트 확장 문법으로 `createElement` 메서드를 호출하기 위한 문법입니다. 
- 즉, 트랜스파일러는 JSX 문법을 `createElement` 메서드 호출문으로 변환하여 `ReactElement`를 생성합니다. 
- 정리하면 `ReactElement` 타입은 `JSX`의 `createElement` 메서드 호출로 생성된 리액트 엘리먼트를 나타내는 타입입니다. 
##### ReactNode
- ReactNode는 리액트의 `render`함수가 반환할 수 있는 모든 형태를 담고 있다고 볼 수 있습니다. 
	- JSX 구문 내에서 사용할 수 있는 모든 요소의 타입
```ts
type ReactNode = 
	| ReactChild // ReacElement | ReactText
	| ReactFragment // ReacElement 배열
	| ReactPortal 
	| boolean 
	| null 
	| undefined
```
##### JSX.Element
- JSX.Element는 ReactEelement의 특정 타입으로 props와 타입 필드를 any로 가지는 타입입니다.
#### 6. 사용 예시
##### ReactNode
- 리액트 컴포넌트가 가질 수 있는 모든 타입을 의미합니다. 
- JSX 형태의 문법을 때로는 string, number, null, undefined 같이 어떤 타입이든 children prop으로 지정할 수 있도록 하고 싶다면 ReactNode 타입으로 children을 선언하면 됩니다.
```ts
type PropsWithChildren<P = unknown> = P & {
	children?: ReactNode | undefined;
};

interface MyProps {}

type MyComponentProps = PropsWithChildren<MyProps>
```
##### JSX.Element
- 리액트 엘리먼트를 Prop으로 전달받아 render props 패턴으로 컴포넌트를 구현할 때 유용하게 활용할 수 있습니다.
```ts
interface Props {
	icon: JSX.Element;
}

const Item = ({ icon }: Props) => {
	// prop으로 받은 컴포넌트의 props에 접근할 수 있습니다. 
	const iconSize = icon.props.size;
	
	return <li>{icon}</li>
}

const App = () => {
	return <Item icon={<Icon size={14} />} />
}
```
##### ReactElement
- JSX.Element 예시를 확장하여 추론 관점에서 더 유용하게 활용할 수 있는 방법은 JSX.Element 대신에 ReactElement를 사용하는 것입니다. 
```ts
interface IconProps {
	size: number;
}

interface Props {
	icon: React.ReactElement<IconProps>
}

const Item = ({ icon }: Props) => {
	// size에 대한 추론이 가능합니다!
	const iconSize = icon.props.size;
	
	return <li>{icon}</li>
}
```
#### 7. 리액트에서 기본 HTML 요소 타입 활용하기
- 기존 HTML 속성 타입을 활용하여 타입을 지정하는 방법에 대해 알아보자
##### DetailedHTMLProps와 ComponentWithoutRef
- HTML 태그의 속성 타입을 활용하는 대표적인 2가지 방법은 리액트의 DetailedHTMLProps와 ComponentPropsWithoutRef 타입을 활용하는 것입니다.
```ts
// DetailedHTMLProps
 type NativeButtonProps = React.DetailedHTMLProps<
	 React.ButtonHTMLAttributes<HTMLButtonElement>,
	 HTMLButtonElement
 >;

 type ButtonProps = {
	 onClick?: NativeButtonProps["onClick"];
 }

// ComponentPropsWithoutRef
type NativeButtonProps = React.ComponentPropsWithoutRef<"button">;

type ButtonProps = {
	 onClick?: NativeButtonProps["onClick"];
 }
```
##### 언제 ComponentPropsWithoutRef를 사용하면 좋을까
- 만약 DOM에 접근하는 경우 ref를 props로 내려주어야하는 경우가 생길 수 있습니다. 
- 이때 함수형 컴포넌트의 경우 클래스 컴포넌트와는 다르게 생성된 인스턴스가 없어 ref에 기대한 값이 할당될 수 없습니다. 
- 이러한 제약을 극복하기 위해 forwardRef 메서드가 있습니다.
- forwardRef는 2개의 제네릭 인자를 통해 ref와 props에 대한 타입을 지정할 수 있습니다.
```ts
type NativeButtonProps = React.ComponentPropsWithoutRef<"button">;

const Button = forward<HTMLButtonElement, NativeButtonProps>((props, ref) => {
	return <button ref={ref} {...props}>버튼</button>
})
```
#### 공변성과 반공변성
- 타입 A가 B의 서브타입일 때, `T<A>` 가 `T<B>`의 서브 타입이 된다면 **공변성**을 띠고 있다고 말합니다. 
```ts
interface User { 
	id: string;
}

interface Member extends User { 
	nickName: string;
}

let users: Array<user> = [];
let members: Array<Member> = [];

users = members; // OK
members = users; // Error
```
- 일반적인 타입들은 공변성을 가지고 있어 좁은 타입에서 넓은 타입으로 할당이 가능합니다. 
- **하지만 제네릭은 반공변성을 가지기 때문에 좁은 타입의 함수를 넓은 타입의 함수에 적용할 수 없습니다.** 
- 안전한 타입 가드를 위해 특수한 경우를 제외하고 반공변적인 함수 타입을 설정하는 것이 권장됩니다. 
```ts
type PrintUserInfo<U extends User> = (user: U) => void

let printUser: PrintUserInfo<User> = (user) => console.log(user.id);

let printMember: PrintUserInfo<Member> = (user) => console.log(user.id, user.nickName);

printUser = printMember;
printMember = printUser;
```